// ***************************************************************************
//
// Reality - The Matrix Online Server Emulator
// Copyright (C) 2006-2010 Rajko Stojadinovic
// http://mxoemu.info
//
// ---------------------------------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// ---------------------------------------------------------------------------
//
// ***************************************************************************

#ifndef SUBPACKETSTEST_H
#define SUBPACKETSTEST_H

#define UNITTEST

#include "Common.h"
#include "ByteBuffer.h"
#include "Crypto.h"
#include "Util.h"
#include "MessageTypes.h"

//packet 0x00
unsigned char Packet1[] =
{
	0x04, 0x01, 0x00, 0x00, 0x13, 0x4F, 0x06, 0x0E, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x51, 0x27, 0xE7, 0x48, 0x01, 0x44, 0x00, 0x34, 0x00, 0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 
	0x65, 0x2F, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x73, 0x2F, 0x66, 0x69, 0x6E, 0x61, 0x6C, 0x5F, 0x77, 
	0x6F, 0x72, 0x6C, 0x64, 0x2F, 0x73, 0x6C, 0x75, 0x6D, 0x73, 0x5F, 0x62, 0x61, 0x72, 0x72, 0x65, 
	0x6E, 0x73, 0x5F, 0x66, 0x75, 0x6C, 0x6C, 0x2E, 0x6D, 0x65, 0x74, 0x72, 0x00, 0x09, 0x00, 0x6E, 
	0x6F, 0x37, 0x74, 0x68, 0x64, 0x61, 0x79, 0x00, 0x0A, 0x80, 0xE5, 0x0C, 0x06, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0A, 0x80, 0xE4, 0xE8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 
	0xB2, 0x4E, 0x00, 0x08, 0x00, 0x08, 0x02, 0x08, 0x80, 0xB2, 0x52, 0x00, 0x05, 0x00, 0x08, 0x02, 
	0x08, 0x80, 0xB2, 0x54, 0x00, 0x08, 0x00, 0x08, 0x02, 0x08, 0x80, 0xB2, 0x4F, 0x00, 0x08, 0x00, 
	0x08, 0x02, 0x08, 0x80, 0xB2, 0x51, 0x00, 0x0B, 0x00, 0x08, 0x02, 0x08, 0x80, 0xB2, 0x11, 0x00, 
	0x01, 0x00, 0x08, 0x02, 0x16, 0x80, 0xBC, 0x45, 0x03, 0x11, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
	0x11, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x45, 0x00, 
	0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x03, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0x08, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x04, 0x00, 
	0x00, 0xF7, 0x03, 0x00, 0x00, 0x07, 0x02, 0xEC, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x16, 0x80, 0xBC, 0x15, 0x00, 0x05, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0x50, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x06, 0x00, 0x00, 0xF7, 
	0x03, 0x00, 0x00, 0xF4, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 
	0xBC, 0x15, 0x00, 0x07, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0x51, 0x04, 0xF6, 0xFF, 0xFF, 0xFF, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x08, 0x00, 0x00, 0xF7, 0x03, 0x00, 
	0x00, 0x52, 0x04, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x00, 0x00, 
	0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1A, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x2E, 0x07, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x2E, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00
} ;

//packet 0x13 (stationtraffic) all data in this packet is also in packet 0x12
unsigned char Packet2[] =
{
	0x04, 
	0x01, 0x00, 0x13, 0x02, 0x25, 0x80, 0x86, 0x52, 0x20, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x81, 0xA5, 0x00, 0x00, 0x07, 
	0x00, 0x05, 0x3F, 0x00, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x74, 0x68, 0x65, 0x6D, 0x61, 
	0x74, 0x72, 0x69, 0x78, 0x6F, 0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x2E, 0x73, 0x74, 0x61, 0x74, 0x69, 
	0x6F, 0x6E, 0x2E, 0x73, 0x6F, 0x6E, 0x79, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x70, 0x72, 0x6F, 0x63, 
	0x65, 0x73, 0x73, 0x46, 0x6C, 0x61, 0x73, 0x68, 0x54, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x2E, 
	0x76, 0x6D, 0x00
} ;

//packet 0x06 (all data in this packet is also in packet 0x00)
unsigned char Packet3[] =
{
	0x04, 0x01, 0x00, 0x06, 0x07, 0x08, 0x80, 0xB2, 0x4F, 0x00, 0x08, 0x00, 0x08, 
	0x02, 0x08, 0x80, 0xB2, 0x51, 0x00, 0x0B, 0x00, 0x08, 0x02, 0x08, 0x80, 0xB2, 0x11, 0x00, 0x01, 
	0x00, 0x08, 0x02, 0x16, 0x80, 0xBC, 0x45, 0x03, 0x11, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x11, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x45, 0x00, 0x02, 
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x03, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0x08, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x04, 0x00, 0x00, 
	0xF7, 0x03, 0x00, 0x00, 0x07, 0x02, 0xEC, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00
} ;

//packet 0x0D (all data in this packet is also in packet 0x00)
unsigned char Packet4[] =
{
	0x04, 
	0x01, 0x00, 0x0D, 0x05, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x05, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 
	0x50, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 
	0x06, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0xF4, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x07, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0x51, 0x04, 
	0xF6, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x08, 0x00, 
	0x00, 0xF7, 0x03, 0x00, 0x00, 0x52, 0x04, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x2F, 0x47, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
} ;

//packet 0x12 and 0x13
unsigned char Packet5[] =
{
	0x04, 
	0x02, 0x00, 0x12, 0x01, 0x24, 0x2E, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x59, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x02, 0x25, 0x80, 0x86, 0x52, 
	0x20, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x48, 0x81, 0xA5, 0x00, 0x00, 0x07, 0x00, 0x05, 0x3F, 0x00, 0x68, 0x74, 0x74, 0x70, 
	0x3A, 0x2F, 0x2F, 0x74, 0x68, 0x65, 0x6D, 0x61, 0x74, 0x72, 0x69, 0x78, 0x6F, 0x6E, 0x6C, 0x69, 
	0x6E, 0x65, 0x2E, 0x73, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x73, 0x6F, 0x6E, 0x79, 0x2E, 
	0x63, 0x6F, 0x6D, 0x2F, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x46, 0x6C, 0x61, 0x73, 0x68, 
	0x54, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x2E, 0x76, 0x6D, 0x00
} ;

//packet 0x0D (all data in this packet is also in packet 0x00)
unsigned char Packet6[] =
{
	0x04, 
	0x01, 0x00, 0x0D, 0x04, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x05, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 
	0x50, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 
	0x06, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0xF4, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x07, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0x51, 0x04, 
	0xF6, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x08, 0x00, 
	0x00, 0xF7, 0x03, 0x00, 0x00, 0x52, 0x04, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
} ;

//packet 0x11 and 0x12 and 0x13
unsigned char Packet7[] =
{
	0x04, 
	0x03, 0x00, 0x11, 0x01, 0x2F, 0x47, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x24, 0x2E, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x01, 0x25, 
	0x80, 0x86, 0x52, 0x20, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 
	0x00, 0x00, 0x00, 0x00, 0x00
} ;

//packet 0x14
unsigned char Packet8[] =
{
	0x04, 
	0x01, 0x00, 0x14, 0x01, 0x48, 0x81, 0xA5, 0x00, 0x00, 0x07, 0x00, 0x05, 0x3F, 0x00, 0x68, 0x74, 
	0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x74, 0x68, 0x65, 0x6D, 0x61, 0x74, 0x72, 0x69, 0x78, 0x6F, 0x6E, 
	0x6C, 0x69, 0x6E, 0x65, 0x2E, 0x73, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x73, 0x6F, 0x6E, 
	0x79, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x46, 0x6C, 0x61, 
	0x73, 0x68, 0x54, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x2E, 0x76, 0x6D, 0x00
} ;

//packet 0x00 AND 0x06 (same data as from 0x00)
unsigned char Packet9[] =
{
	0x04, 0x02, 0x00, 0x00, 0x06, 0x4F, 0x06, 0x0E, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x51, 0x27, 0xE7, 0x48, 0x01, 0x44, 0x00, 0x34, 0x00, 0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 
	0x65, 0x2F, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x73, 0x2F, 0x66, 0x69, 0x6E, 0x61, 0x6C, 0x5F, 0x77, 
	0x6F, 0x72, 0x6C, 0x64, 0x2F, 0x73, 0x6C, 0x75, 0x6D, 0x73, 0x5F, 0x62, 0x61, 0x72, 0x72, 0x65, 
	0x6E, 0x73, 0x5F, 0x66, 0x75, 0x6C, 0x6C, 0x2E, 0x6D, 0x65, 0x74, 0x72, 0x00, 0x09, 0x00, 0x6E, 
	0x6F, 0x37, 0x74, 0x68, 0x64, 0x61, 0x79, 0x00, 0x0A, 0x80, 0xE5, 0x0C, 0x06, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0A, 0x80, 0xE4, 0xE8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 
	0xB2, 0x4E, 0x00, 0x08, 0x00, 0x08, 0x02, 0x08, 0x80, 0xB2, 0x52, 0x00, 0x05, 0x00, 0x08, 0x02, 
	0x08, 0x80, 0xB2, 0x54, 0x00, 0x08, 0x00, 0x08, 0x02, 0x00, 0x06, 0x01, 0x08, 0x80, 0xB2, 0x4F, 
	0x00, 0x08, 0x00, 0x08, 0x02
} ;

//packet 0x07 AND 0x0D (same data as packet 0x00)
unsigned char Packet10[] =
{
	0x04, 
	0x02, 0x00, 0x07, 0x06, 0x08, 0x80, 0xB2, 0x51, 0x00, 0x0B, 0x00, 0x08, 0x02, 0x08, 0x80, 0xB2, 
	0x11, 0x00, 0x01, 0x00, 0x08, 0x02, 0x16, 0x80, 0xBC, 0x45, 0x03, 0x11, 0x00, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x11, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 
	0x45, 0x00, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x03, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 
	0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 
	0x04, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0x07, 0x02, 0xEC, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0D, 0x01, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x05, 0x00, 0x00, 0xF7, 0x03, 0x00, 
	0x00, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
} ;

//packet 0x0e AND 0x11 AND 0x12 (just data as packet 0x00)
unsigned char Packet11[] =
{
	0x04, 
	0x03, 0x00, 0x0E, 0x03, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x06, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 
	0xF4, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 
	0x07, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0x51, 0x04, 0xF6, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x08, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0x52, 0x04, 
	0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x01, 0x2F, 0x47, 0x00, 0x00, 
	0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1A, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x24, 
	0x2E, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 
	0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00
} ;

//packet 0x13
unsigned char Packet12[] =
{
	0x04, 
	0x02, 0x00, 0x13, 0x01, 0x25, 0x80, 0x86, 0x52, 0x20, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x01, 0x48, 0x81, 0xA5, 
	0x00, 0x00, 0x07, 0x00, 0x05, 0x3F, 0x00, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x74, 0x68, 
	0x65, 0x6D, 0x61, 0x74, 0x72, 0x69, 0x78, 0x6F, 0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x2E, 0x73, 0x74, 
	0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x73, 0x6F, 0x6E, 0x79, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x70, 
	0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x46, 0x6C, 0x61, 0x73, 0x68, 0x54, 0x72, 0x61, 0x66, 0x66, 
	0x69, 0x63, 0x2E, 0x76, 0x6D, 0x00
} ;

//packet 0x00 and 0x06
unsigned char Packet13[] =
{
	0x04, 0x02, 0x00, 0x00, 0x06, 0x4F, 0x06, 0x0E, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x51, 0x27, 0xE7, 0x48, 0x01, 0x44, 0x00, 0x34, 0x00, 0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 
	0x65, 0x2F, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x73, 0x2F, 0x66, 0x69, 0x6E, 0x61, 0x6C, 0x5F, 0x77, 
	0x6F, 0x72, 0x6C, 0x64, 0x2F, 0x73, 0x6C, 0x75, 0x6D, 0x73, 0x5F, 0x62, 0x61, 0x72, 0x72, 0x65, 
	0x6E, 0x73, 0x5F, 0x66, 0x75, 0x6C, 0x6C, 0x2E, 0x6D, 0x65, 0x74, 0x72, 0x00, 0x09, 0x00, 0x6E, 
	0x6F, 0x37, 0x74, 0x68, 0x64, 0x61, 0x79, 0x00, 0x0A, 0x80, 0xE5, 0x0C, 0x06, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0A, 0x80, 0xE4, 0xE8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 
	0xB2, 0x4E, 0x00, 0x08, 0x00, 0x08, 0x02, 0x08, 0x80, 0xB2, 0x52, 0x00, 0x05, 0x00, 0x08, 0x02, 
	0x08, 0x80, 0xB2, 0x54, 0x00, 0x08, 0x00, 0x08, 0x02, 0x00, 0x06, 0x01, 0x08, 0x80, 0xB2, 0x4F, 
	0x00, 0x08, 0x00, 0x08, 0x02
} ;

//packet 0x08 and 0x0D
unsigned char Packet14[] =
{
	0x04, 0x02, 0x00, 0x08, 0x05, 0x08, 0x80, 0xB2, 0x11, 0x00, 0x01, 0x00, 0x08, 
	0x02, 0x16, 0x80, 0xBC, 0x45, 0x03, 0x11, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x11, 0x00, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x45, 0x00, 0x02, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 
	0x80, 0xBC, 0x15, 0x00, 0x03, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x80, 0xBC, 0x15, 0x00, 0x04, 0x00, 0x00, 0xF7, 0x03, 
	0x00, 0x00, 0x07, 0x02, 0xEC, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x01, 
	0x16, 0x80, 0xBC, 0x15, 0x00, 0x05, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0x50, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
} ;

typedef struct 
{
	uint16 sequenceId;
	list<ByteBuffer> subPackets;

	void FromBuffer(ByteBuffer &source)
	{
		{
			uint16 theId;
			source >> theId;
			sequenceId = swap16(theId);
		}
		uint8 numSubPackets;
		source >> numSubPackets;
		subPackets.clear();
		for (uint8 i=0;i<numSubPackets;i++)
		{
			uint8 subPacketSize;
			source >> subPacketSize;
			vector<byte> dataBuf(subPacketSize);
			source.read(&dataBuf[0],dataBuf.size());
			subPackets.push_back(ByteBuffer(&dataBuf[0],dataBuf.size()));
		}
	}
	void FromBuffer(const byte* buf,size_t size)
	{
		ByteBuffer derp;
		derp.append(buf,size);
		derp.wpos(0);
		derp.rpos(0);
		return FromBuffer(derp);
	}
	void ToBuffer(ByteBuffer &destination)
	{
		destination << uint16(swap16(sequenceId));

		uint8 numSubPackets = subPackets.size();
		destination << uint8(numSubPackets);
		for (list<ByteBuffer>::iterator it=subPackets.begin();it!=subPackets.end();++it)
		{
			destination << uint8(it->size());
			destination.append(it->contents(),it->size());
		}
	}
}MsgBlock;

struct OrderedPacket
{
	list<MsgBlock> msgBlocks;

	void FromBuffer(ByteBuffer &source)
	{
		uint8 zeroFourId=0;
		source >> zeroFourId;
		if (zeroFourId != 0x04)
		{
			cout << "invalid 04 packet" << endl;
			return;
		}

		uint8 numOrderPackets=0;
		source >> numOrderPackets;
		msgBlocks.clear();
		for (uint8 i=0;i<numOrderPackets;i++)
		{
			MsgBlock thePacket;
			thePacket.FromBuffer(source);
			msgBlocks.push_back(thePacket);
		}
	}
	void FromBuffer(const byte* buf,size_t size)
	{
		ByteBuffer derp;
		derp.append(buf,size);
		derp.wpos(0);
		derp.rpos(0);
		return FromBuffer(derp);
	}
	void ToBuffer(ByteBuffer &destination)
	{
		destination << uint8(0x04);
		destination << uint8(msgBlocks.size());

		for (list<MsgBlock>::iterator it=msgBlocks.begin();it!=msgBlocks.end();++it)
		{
			it->ToBuffer(destination);
		}
	}

};

bool CheckForDuplicates(ByteBuffer *what,list<MsgBlock> &whereToLook)
{
	for (list<MsgBlock>::iterator it=whereToLook.begin();it!=whereToLook.end();++it)
	{
		for(list<ByteBuffer>::iterator it2=it->subPackets.begin();it2!=it->subPackets.end();++it2)
		{
			if (&(*it2)==what) //we ran into ourselves
				continue;

			if (it2->size() == what->size())
			{
				if (memcmp(it2->contents(),what->contents(),it2->size())==0)
				{
					return true;
				}
			}
		}
	}
	return false;
}

void runTest()
{
	list<OrderedPacket> packets;
	OrderedPacket currPacket;
	currPacket.FromBuffer(Packet1,sizeof(Packet1));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet2,sizeof(Packet2));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet3,sizeof(Packet3));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet4,sizeof(Packet4));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet5,sizeof(Packet5));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet6,sizeof(Packet6));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet7,sizeof(Packet7));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet8,sizeof(Packet8));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet9,sizeof(Packet9));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet10,sizeof(Packet10));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet11,sizeof(Packet11));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet12,sizeof(Packet12));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet13,sizeof(Packet13));
	packets.push_back(currPacket);
	currPacket.FromBuffer(Packet14,sizeof(Packet14));
	packets.push_back(currPacket);

	list<MsgBlock> separatePackets;
	for (list<OrderedPacket>::iterator it=packets.begin();it!=packets.end();++it)
	{
		for (list<MsgBlock>::iterator it2=it->msgBlocks.begin();it2!=it->msgBlocks.end();++it2)
		{
			separatePackets.push_back(*it2);
		}
	}

	cout << "derp" << endl;

	bool restartLoop=false;
	bool doLoop=true;
	while (doLoop)
	{
		for (list<MsgBlock>::reverse_iterator it=separatePackets.rbegin();it!=separatePackets.rend();++it)
		{
			if (restartLoop)
			{
				restartLoop=false;
				break;
			}

			for(list<ByteBuffer>::reverse_iterator it2=it->subPackets.rbegin();it2!=it->subPackets.rend();++it2)
			{
				if (CheckForDuplicates(&(*it2),separatePackets)==true)
				{
					list<ByteBuffer>::iterator derp = it2.base();
					derp--;
					it->subPackets.erase(derp);
					restartLoop=true;
					break;
				}
			}

			list<MsgBlock>::reverse_iterator isItOver=it;
			isItOver++;
			if (isItOver==separatePackets.rend())
			{
				doLoop=false;
				break;
			}
		}
	}

	for (list<MsgBlock>::iterator it=separatePackets.begin();it!=separatePackets.end();++it)
	{
		if (it->subPackets.size() < 1)
		{
			it = separatePackets.erase(it);
			it--;
		}
	}

	vector<ByteBuffer> hurr;
	for (list<MsgBlock>::iterator it=separatePackets.begin();it!=separatePackets.end();++it)
	{
		for (list<ByteBuffer>::iterator it2=it->subPackets.begin();it2!=it->subPackets.end();++it2)
		{
			hurr.push_back(*it2);
		}
	}

	for (int i=0;i<hurr.size();i++)
	{
		cout << "Packet " << i+1 << ":" << endl;
		cout << Bin2Hex(hurr[i]) << endl;
	}

	cout << Bin2Hex(LoadWorldCmd(LoadWorldCmd::SLUMS,"satiSky").toBuf()) << endl;
	cout << Bin2Hex(HexGenericMsg("80 bc 15 00 07 00 00 f7 03 00 00 51 04 f6 ff ff ff 00 00 00 00 00").toBuf()) << endl;
	cout << Bin2Hex(SetInformationCmd(35353525534).toBuf()) << endl;
	cout << Bin2Hex(SetExperienceCmd(93893583959).toBuf()) << endl;
}

#endif